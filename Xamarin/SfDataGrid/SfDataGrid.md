# SfDataGrid

The **SfDataGrid** control is available in Xamarin.Forms, Xamarin.Android and Xamarin.iOS. It helps you to create entirely customizable features used to display and manipulate a large amount of data in a tabular view. The following table lists the key features of the **SfDataGrid** in Xamarin.Forms, Xamarin.Android and Xamarin.iOS.

<table>
<tr>
<th colspan=1 rowspan=1>Features<br/></th>
<th colspan=1 rowspan=1>Xamarin.Forms<br/></th>
<th colspan=1 rowspan=1>Xamarin.Android<br/></th>
<th colspan=1 rowspan=1>Xamarin.iOS<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>Diagonal Scrolling<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"></i><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"></i><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"></i><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Sorting<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Custom Sorting<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Grouping<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Custom Grouping<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Summaries<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Filtering<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Selection<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Load More<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Pull To Refresh<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Template Column<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-close"></i><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-close"></i><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Custom Cell<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-close"></i><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Styles<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Conditional Styles<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-close"></i><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-close"></i><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Exporting<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Row Freezing<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Column Freezing<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Row Height Customization<br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
<td colspan=1 rowspan=1><i class="fa fa-check"><br/></td>
</tr>
</table>

## Getting Started

This section provides a quick overview for working with **SfDataGrid** for Xamarin.Forms, Xamarin.Android and Xamarin.iOS. You will walk through the entire process of creating a real world **SfDataGrid**.

### Assembly deployment

After installing Essential Studio for Xamarin, you can find all the required assemblies in the installation folders,

{Syncfusion Essential Studio Installed location}\Essential Studio\{{ site.releaseversion }}\lib

Eg: C:\Program Files (x86)\Syncfusion\Essential Studio\{{ site.releaseversion }}\lib

N> Assemblies can be found in unzipped package location in Mac

#### SfDataGrid for Xamarin.Forms

The following list of assemblies need to be added as reference from the lib folder to use **SfDataGrid** in your application.

<table>
<tr>
<th colspan=1 rowspan=1>Project<br/></th>
<th colspan=1 rowspan=1>Required assemblies<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>Pcl<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.Data.Portable.dll<br/>pcl\Syncfusion.GridCommon.Portable.dll<br/>pcl\Syncfusion.SfDataGrid.XForms.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Android Renderer<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.Data.Portable.dll<br/>pcl\Syncfusion.GridCommon.Portable.dll<br/>pcl\Syncfusion.SfDataGrid.XForms.dll<br/>android\Syncfusion.SfDataGrid.XForms.Android.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>iOS Renderer<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.Data.Portable.dll<br/>pcl\Syncfusion.GridCommon.Portable.dll<br/>pcl\Syncfusion.SfDataGrid.XForms.dll<br/>ios-unified\Syncfusion.SfDataGrid.XForms.iOS.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>WindowsPhone Renderer<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.Data.Portable.dll<br/>pcl\Syncfusion.GridCommon.Portable.dll<br/>pcl\Syncfusion.SfDataGrid.XForms.dll<br/>wp8\Syncfusion.SfDataGrid.XForms.WinPhone.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>WindowsPhone 8.1 Renderer<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.Data.Portable.dll<br/>pcl\Syncfusion.GridCommon.Portable.dll<br/>pcl\Syncfusion.SfDataGrid.XForms.dll<br/>wp81\Syncfusion.SfDataGrid.XForms.WinPhone.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>WinRT Renderer<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.Data.Portable.dll<br/>pcl\Syncfusion.GridCommon.Portable.dll<br/>pcl\Syncfusion.SfDataGrid.XForms.dll<br/>winrt\Syncfusion.SfDataGrid.XForms.WinRT.dll<br/></td>
</tr>
</table>

In order to use export to excel and export to pdf functionalities of **SfDataGrid**, add the below assembly to your pcl project.

<table>
<tr>
<th colspan=1 rowspan=1>Project<br/></th>
<th colspan=1 rowspan=1>Required assemblies<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>Pcl<br/></td>
<td colspan=1 rowspan=1>pcl\Syncfusion.SfGridConverter.XForms.dll<br/>pcl\Syncfusion.Compression.Portable.dll<br/>pcl\Syncfusion.Pdf.Portable.dll<br/>pcl\Syncfusion.XlsIO.Portable.dll<br/></td>
</tr>
</table>

Currently, an additional step is required for Windows Phone, WindowsPhone 8.1, WinRT and iOS projects. You need to initialize the SfDataGridRenderer. 

Call the SfDataGridRenderer.Init() in the MainPage constructor of the Windows Phone, Windows Phone 8.1 and WinRT projects as follows.

{% tabs %}{% highlight c# %}
public MainPage()
{
…
SfDataGridRenderer.Init();
…
}

{% endhighlight %}


Call the SfDataGridRenderer.Init() in the FinishedLaunching overridden method of the AppDelegate class in the iOS Project as follows.

{% highlight c# %}
public override bool FinishedLaunching(UIApplication app, NSDictionary options)
{
…
SfDataGridRenderer.Init();
…
}

{% endhighlight %}

{% endtabs %}

#### SfDataGrid for Xamarin.Android and Xamrain.iOS

The following list of assemblies need to be added as reference from the lib folder to use **SfDataGrid** in your application.

<table>
<tr>
<th colspan=1 rowspan=1>Project<br/></th>
<th colspan=1 rowspan=1>Required assemblies<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>Xamarin.Android<br/></td>
<td colspan=1 rowspan=1>Syncfusion.Linq.Android.dll<br/>Syncfusion.SfDataGrid.Android.dll<br/>Syncfusion.GridCommon.Portable.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Xamarin.iOS<br/></td>
<td colspan=1 rowspan=1>Syncfusion.Linq.iOS.dll<br/>Syncfusion.SfDataGrid.iOS.dll<br/>Syncfusion.GridCommon.Portable.dll<br/></td>
</tr>
</table>

In order to use export to excel and export to pdf functionalities of **SfDataGrid**, add the below assembly to your project.

<table>
<tr>
<th colspan=1 rowspan=1>Project<br/></th>
<th colspan=1 rowspan=1>Required assemblies<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>Xamarin.Android<br/></td>
<td colspan=1 rowspan=1>Syncfusion.SfGridConverter.Android.dll<br/>pcl\Syncfusion.Compression.Portable.dll<br/>pcl\Syncfusion.Pdf.Portable.dll<br/>pcl\Syncfusion.XlsIO.Portable.dll<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>Xamarin.iOS<br/></td>
<td colspan=1 rowspan=1>Syncfusion.SfGridConverter.iOS.dll<br/>pcl\Syncfusion.Compression.Portable.dll<br/>pcl\Syncfusion.Pdf.Portable.dll<br/>pcl\Syncfusion.XlsIO.Portable.dll<br/></td>
</tr>
</table>

### Create a simple SfDataGrid 

This section explains how to create a **SfDataGrid** and configure it. The **SfDataGrid** control can be configured entirely in C# code or by using XAML markup. This is how the final output will look like on iOS, Android and Windows Phone devices.
 
![](SfDataGrid_images/SfDataGrid-Xamarin_img2.png)

You can download the entire source code of this demo for Xamarin.Forms from [here](http://files2.syncfusion.com/Installs/v13.2.0.29/Samples/Xamarin/DataGrid_GettingStartedForms.zip). 
You can download the entire source code of this demo for Xamarin.Android from [here](http://files2.syncfusion.com/Installs/v13.2.0.29/Samples/Xamarin/DataGrid_GettingStartedAndroid.zip). 
You can download the entire source code of this demo for Xamarin.iOS from [here](http://files2.syncfusion.com/Installs/v13.2.0.29/Samples/Xamarin/DataGrid_GettingStartediOS.zip). 

In this walk through, you will create a new application that contains the **SfDataGrid** which includes the below topics.

* [Creating the project](#Creating-the-project) 

* [Adding SfDataGrid in Xamarin.Forms](#Adding-SfDataGrid-in-Xamarin.Forms) 

* [Adding SfDataGrid in Xamarin.Android](#Adding-SfDataGrid-in-Xamarin.Android) 

* [Adding SfDataGrid in Xamarin.iOS](#Adding-SfDataGrid-in-Xamarin.iOS)

* [Create data model](#Create-DataModel-for-the-SfDataGrid)  

* [Binding data](#Binding-data-to-SfDataGrid) 

* [Defining columns](#Defining-Columns) 

* [Sorting](#Sorting) 

* [Grouping](#Grouping) 

* [Selection](#Selection) 


#### Creating the project

Create a new BlankApp (Xamarin.Forms.Portable) application in Xamarin Studio or Visual Studio for Xamarin.Forms.
Create a new Android application in Xamarin Studio or Visual Studio for Xamarin.Android.
Create a new iOS application in Xamarin Studio or Visual Studio for Xamarin.iOS.

#### Adding SfDataGrid in Xamarin.Forms 

1. Add the required assembly references to the pcl and renderer projects as discussed in the [](#_Assembly_deployment "") HYPERLINK \l "_Assembly_deployment" section.

2. Import **SfDataGrid** control namespace Syncfusion.SfDataGrid.XForms.

3. Declare **SfDataGrid** control as content to the ContentPage.


{% tabs %}{% highlight c# %}
[C#]
using Syncfusion.SfDataGrid.XForms;
using Xamarin.Forms;

namespace GettingStarted
{
public class App : Application
{
SfDataGrid dataGrid;
public App()
{
dataGrid = new SfDataGrid();
MainPage = new ContentPage { Content = dataGrid };
}
}
} 



{% endhighlight %}

{% highlight xml %}
[XAML]
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:local="clr-namespace:GettingStarted;assembly=GettingStarted"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms" 
x:Class="GettingStarted.Sample">

<ContentPage.Content>
<syncfusion:SfDataGrid x:Name="dataGrid" />
</ContentPage.Content>
</ContentPage> 



{% endhighlight %}

#### Adding SfDataGrid in Xamarin.Android

1. Add the required assembly references to the project as discussed in the [](#_Assembly_deployment "") HYPERLINK \l "_Assembly_deployment" section.

2. Import **SfDataGrid** control namespace Syncfusion.SfDataGrid.

3. Create a **SfDataGrid** control instance and add as a child to the view hosted in the Activity.


{% highlight c# %}

using Syncfusion.SfDataGrid; 

[Activity (Label = "GettingStarted", MainLauncher = true)]
public class MainActivity : Activity
{
SfDataGrid dataGrid;
protected override void OnCreate (Bundle bundle)
{
base.OnCreate (bundle);
SetContentView (Resource.Layout.Main);
RelativeLayout layout = (RelativeLayout)FindViewById (Resource.Id.Relative);
dataGrid = new SfDataGrid (BaseContext);
layout.AddView (dataGrid);
}
}


{% endhighlight %}

#### Adding SfDataGrid in Xamarin.iOS

1. Add the required assembly references to the project as discussed in the [](#_Assembly_deployment "") HYPERLINK \l "_Assembly_deployment" section.

2. Import **SfDataGrid** control namespace Syncfusion.SfDataGrid.

3. Create a **SfDataGrid** control instance and add as a SubView to a UIViewController.


{% highlight c# %}

using Syncfusion.SfDataGrid; 
public partial class GettingStartedViewController : UIViewController
{
SfDataGrid dataGrid;

static bool UserInterfaceIdiomIsPhone {
get { return UIDevice.CurrentDevice.UserInterfaceIdiom == UIUserInterfaceIdiom.Phone; }
}

public GettingStartedViewController ()
: base (UserInterfaceIdiomIsPhone ? "GettingStartedViewController_iPhone" : "GettingStartedViewController_iPad", null)
{
dataGrid = new SfDataGrid ();
dataGrid.HeaderRowHeight = 45;
dataGrid.RowHeight = 45;
}

public override void ViewDidLoad ()
{
base.ViewDidLoad ();
dataGrid.Frame = new CGRect (0, 30, View.Frame.Width, View.Frame.Height);
View.AddSubview (dataGrid);
}
} 


{% endhighlight %}

#### Create DataModel for the SfDataGrid

**SfDataGrid** is a data-bound control. Hence you must create a data model to bind it to the control. 

1. Create a simple data source as shown in the following code example in a new class file and save it as OrderInfo.cs file. 

{% highlight c# %}

public class OrderInfo
{
private int orderID;
private string customerID;
private string customer;
private string shipCity;
private string shipCountry;

public int OrderID {
get { return orderID; }
set { this.orderID = value; }
}

public string CustomerID {
get { return customerID; }
set { this.customerID = value; }
}

public string ShipCountry {
get { return shipCountry; }
set { this.shipCountry = value; }
}

public string Customer {
get { return this.customer; }
set { this.customer = value; }
}

public string ShipCity {
get { return shipCity; }
set { this.shipCity = value; }
}

public OrderInfo (int orderId, string customerId, string country, string customer, string shipCity)
{
this.OrderID = orderId;
this.CustomerID = customerId;
this.Customer = customer;
this.ShipCountry = country;
this.ShipCity = shipCity;
}
} 


{% endhighlight %}

Note: If you want your data model to respond to property changes, then implement INotifyPropertyChanged interface in your model class

2. Create a model repository class with OrderInfo collection property initialized with required number of data objects as shown in the following code example in a new class file and save it as OrderInfoRepository.cs file.

{% highlight c# %}

public class OrderInfoRepository
{
private ObservableCollection<OrderInfo> orderInfo;
public ObservableCollection<OrderInfo> OrderInfoCollection {
get { return orderInfo; }
set { this.orderInfo = value; }
}
public OrderInfoRepository ()
{
orderInfo = new ObservableCollection<OrderInfo> ();
this.GenerateOrders ();
}
private void GenerateOrders ()
{
orderInfo.Add (new OrderInfo (1001, "Maria Anders", "Germany", "ALFKI", "Berlin"));
orderInfo.Add (new OrderInfo (1002, "Ana Trujilo", "Mexico", "ANATR", "México D.F."));
orderInfo.Add (new OrderInfo (1003, "Ant Fuller", "Mexico", "ANTON", "México D.F."));
orderInfo.Add (new OrderInfo (1004, "Thomas Hardy", "UK", "AROUT", "London"));
orderInfo.Add (new OrderInfo (1005, "Tim Adams", "Sweden", "BERGS", "Luleå"));
orderInfo.Add (new OrderInfo (1006, "Hanna Moos", "Germany", "BLAUS", "Mannheim"));
orderInfo.Add (new OrderInfo (1007, "Andrew Fuller", "France", "BLONP", "Strasbourg"));
orderInfo.Add (new OrderInfo (1008, "Martin King", "Spain", "BOLID", "Madrid"));
orderInfo.Add (new OrderInfo (1009, "Lenny Lin", "France", "BONAP", "Marseille"));
orderInfo.Add (new OrderInfo (1010, "John Carter", "Canada", "BOTTM", "Tsawassen"));
orderInfo.Add (new OrderInfo (1011, "Lauro King", "UK", "AROUT", "London"));
orderInfo.Add (new OrderInfo (1012, "Anne Wilson", "Germany", "BLAUS", "Mannheim"));
orderInfo.Add (new OrderInfo (1013, "Alfki Kyle", "France", "BLONP", "Strasbourg"));
orderInfo.Add (new OrderInfo (1014, "Gina Irene", "UK", "AROUT", "London"));
}
} 


{% endhighlight %}

#### Binding data to SfDataGrid

In order to bind the data source of the **SfDataGrid**, set the **SfDataGrid.ItemsSource** property as shown below. You can bind the data source of the **SfDataGrid** either from XAML or in code. 
The following code example bind the collection created in previous step to **SfDataGrid.ItemsSource** property.

{% highlight c# %}
[C#]
OrderInfoRepository viewModel = new OrderInfoRepository ();
dataGrid.ItemsSource = viewModel.OrderInfoCollection; 



{% endhighlight %}

{% highlight xml %}
[XAML]
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:local="clr-namespace:GettingStarted;assembly=GettingStarted"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms" 
x:Class="GettingStarted.Sample">

<ContentPage.BindingContext>
<local:OrderInfoRepository x:Name="viewModel" />
</ContentPage.BindingContext>

<ContentPage.Content>
<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrderInfoCollection}">
</syncfusion:SfDataGrid>
</ContentPage.Content>
</ContentPage> 



{% endhighlight %}

Now run the application to render the following output.
![](SfDataGrid_images/SfDataGrid-Xamarin_img3.png)

#### Defining Columns

By default, the **SfDataGrid** automatically creates columns for all the properties in the data source. The type of the column generated depends on the type of data in the column. When the columns are auto-generated, you can handle the AutoGeneratingColumn event to customize or cancel the columns before they are added to the Columns collection in **SfDataGrid**. 
You can also define the columns manually by setting the **SfDataGrid.AutoGenerateColumns** property to false and by adding the GridColumn objects to the **SfDataGrid.Columns** collection. It can be done from both XAML and code. The following code example illustrates this. 

{% highlight c# %}
[C#]
dataGrid.AutoGenerateColumns = false;

GridTextColumn orderIdColumn = new GridTextColumn ();
orderIdColumn.MappingName = "OrderID";
orderIdColumn.HeaderText = "Order ID";

GridTextColumn customerIdColumn = new GridTextColumn ();
customerIdColumn.MappingName = "CustomerID";
customerIdColumn.HeaderText = "Customer ID";

GridTextColumn customerColumn = new GridTextColumn ();
customerColumn.MappingName = "Customer";
customerColumn.HeaderText = "Customer";

GridTextColumn countryColumn = new GridTextColumn ();
countryColumn.MappingName = "ShipCountry";
countryColumn.HeaderText = "Ship Country";

dataGrid.Columns.Add (orderIdColumn);
dataGrid.Columns.Add (customerIdColumn);
dataGrid.Columns.Add (customerColumn);
dataGrid.Columns.Add (countryColumn); 

{% endhighlight %}

{% highlight xml %}
[XAML]
<syncfusion:SfDataGrid x:Name="dataGrid"
ColumnSizer="Star"
AutoGenerateColumns="False"
ItemsSource="{Binding OrderInfoCollection}">

<syncfusion:SfDataGrid.Columns x:TypeArguments="syncfusion:Columns">
<syncfusion:GridTextColumn HeaderText="Order ID" 
MappingName="OrderID" />
<syncfusion:GridTextColumn HeaderText="Customer ID"
MappingName="CustomerID" />
<syncfusion:GridTextColumn MappingName="Customer" />
<syncfusion:GridTextColumn HeaderText="Ship Country"
MappingName="ShipCountry" />
</syncfusion:SfDataGrid.Columns>
</syncfusion:SfDataGrid>



{% endhighlight %}

#### Sorting

**SfDataGrid** allows you to apply sorting on its data by setting the **SfDataGrid.AllowSorting** property to true. 
{% highlight c# %}
[C#]
dataGrid.AllowSorting = true; 


{% endhighlight %}

{% highlight xml %}
[XAML]
<syncfusion:SfDataGrid AllowSorting="True" />


{% endhighlight %}


Run the application and touch the header cell to sort the data and the following output is displayed. 
![](SfDataGrid_images/SfDataGrid-Xamarin_img4.png)


You can also configure sorting by adding the column to the **SfDataGrid.SortColumnDescriptions collection as below,
{% highlight c# %}
[C#]
dataGrid.SortColumnDescriptions.Add (new SortColumnDescription () { ColumnName = "CustomerID" });


{% endhighlight %}

{% highlight xml %}
[XAML]
<syncfusion:SfDataGrid.SortColumnDescriptions>
<syncfusion:SortColumnDescription ColumnName="CustomerID" />
</syncfusion:SfDataGrid.SortColumnDescriptions> 



{% endhighlight %}

#### Grouping

**SfDataGrid** allows you to group a column by adding the column to the **SfDataGrid.GroupColumnDescriptions** collection as shown below,

{% highlight c# %}
[C#]
dataGrid.GroupColumnDescriptions.Add (new GroupColumnDescription () { ColumnName = "ShipCountry" });


{% endhighlight %}

{% highlight xml %}
[XAML]
<syncfusion:SfDataGrid.GroupColumnDescriptions>
<syncfusion:GroupColumnDescription ColumnName="ShipCountry" />
</syncfusion:SfDataGrid.GroupColumnDescriptions> 



{% endhighlight %}

Run the application to render the following output. 
![](SfDataGrid_images/SfDataGrid-Xamarin_img5.png)

#### Selection

**SfDataGrid** allows you to select the row/rows by setting the **SfDataGrid.SelectionMode** property. You can set the **SfDataGrid.SelectionMode** property to single, multiple, single deselect or none based on your requirements. Information about the row/rows selected can be tracked using **SfDataGrid.SelectedItem** and **SfDataGrid.SelectedItems** properties.
You can handle the selection operations with the help of SelectionChanging and SelectionChanged events of **SfDataGrid**.

## Data Binding

The **SfDataGrid** is bound to an external data source to display the data. It supports the data sources such as List, Observable Collection, and so on. **SfDataGrid.ItemsSource** property helps to bind the **SfDataGrid** with the collection of objects.
In order to bind the data source of the **SfDataGrid**, set the **SfDataGrid.ItemsSource** property as shown below such that each row in the **SfDataGrid** would bind to an object in the data source and each column would bind to a property in the data model object.
{% highlight c# %}

OrderInfoRepository viewModel = new OrderInfoRepository ();
dataGrid.ItemsSource = viewModel.OrderInfoCollection; 



{% endhighlight %}

If the data source implements ICollectionChanged interface, then **SfDataGrid** will automatically refresh the view when an item is added, removed or while list cleared. When you add or remove an item in ObservableCollection, the **SfDataGrid** automatically refreshes the view as ObservableCollection implements INotifyCollectionChanged. But when you do the same in List, **SfDataGrid** will not refresh the view automatically.
If the data model implements the INotifyPropertyChanged interface, then the **SfDataGrid** responds to the property change in runtime to update the view.
## Columns 

This section explains you about how to create and add columns, different ways to create columns and about the customizations that can done for a column.
**SfDataGrid** allows you to create and add Columns in two ways:

* Automatic Columns generation based on the underlying collection.

* Manually defining columns in XAML or C#.

### Automatic Columns Generation

The **SfDataGrid** creates columns automatically based on the property **SfDataGrid.AutoGenerateColumns**. **SfDataGrid.AutoGenerateColumns** is a bindable property and it decides columns generation for **SfDataGrid** based on the **SfDataGrid.AutoGenerateColumnsMode** property. 
**SfDataGrid.AutoGenerateColumnsMode** decides a way to create columns when **SfDataGrid.AutoGenerateColumns** is set to ‘true’. This enum type has the following four options.

* Reset: Retains the columns defined explicitly in application level and creates columns newly for all the other properties in a Data Source.

* ResetAll: When changing ItemsSource, the columns for previous data are cleared and it creates new columns. Even when columns are explicitly defined it does not consider the defined columns and creates column based on the underlying collection.

* RetainOld: Creates columns for all fields in a Data Source when the Grid does not have any explicit definition for columns. When columns are defined explicitly, then the defined columns alone are retained and new columns are not created.

* SmartReset: Retains the columns defined explicitly in application level and the columns with MappingName identical to properties in a Data Source. Creates columns newly for all the other properties in the Data Source.

* None: Stores only the columns that are defined in **SfDataGrid.Columns** collection.

The default value of **SfDataGrid.AutoGenerateColumns** property is true and **SfDataGrid.AutoGenerateColumnsMode** is Reset. Hence by default **SfDataGrid** creates columns automatically for every non-explicitly defined public property in the underlying collection bound to its ItemsSource property.

NOTE: When you change items source for **SfDataGrid** during run time, then the columns are generated on the basis of option set for AutoGenerateColumnsMode.

#### Customize Automatically Generated Columns

When AutoGenerateColumns is true, then **SfDataGrid.AutoGeneratingColumn** event is raised for each column. This event receives two arguments namely sender which is the **SfDataGrid** and AutoGeneratingColumnArgs.
The AutoGeneratingColumnArgs object contains the following property:

* Column: This property returns the created column using which you can customize the column.

* Cancel: This property cancels the column creation.

You can skip generating a column by handling the **SfDataGrid.AutoGeneratingColumn** event as shown below.

{% highlight c# %}
dataGrid.AutoGeneratingColumn += GridAutoGeneratingColumns; 

void GridAutoGeneratingColumns(object sender, AutoGeneratingColumnArgs e)
{
if (e.Column.MappingName == "EmployeeID")
e.Cancel = true;
}

{% endhighlight %}

You can also apply formatting for auto generated column as shown below.
{% highlight c# %}
void GridAutoGeneratingColumns(object sender, AutoGeneratingColumnArgs e)
{
if (e.Column.MappingName == "Freight") {
e.Column.Format = "C";
e.Column.CultureInfo = new CultureInfo ("en-US");
} else if (e.Column.MappingName == "ShippingDate")
e.Column.Format = "dd/MM/yyyy";
} 

{% endhighlight %}

You can also customize a column’s header text, sorting, alignment, padding, etc. by handling the **SfDataGrid.AutoGeneratingEvent**.

### Manually generate Columns

**SfDataGrid** also allows you to define the columns manually by adding the GridColumn objects to the **SfDataGrid.Columns** collection. In case if you want only the manually defined columns to be in view, then you can achieve it by setting the **SfDataGrid.AutoGenerateColumns** property to false. There are different [](#_Types_of_Columns "") HYPERLINK \l "_Types_of_Columns" available in **SfDataGrid** and you can create any column based on your requirements from both XAML and code. 
The following code example illustrates about creating columns manually using XAML.
{% highlight xml %}
<syncfusion:SfDataGrid x:Name="dataGrid"
ColumnSizer="Star"
AutoGenerateColumns="False"
ItemsSource="{Binding OrderInfoCollection}">

<syncfusion:SfDataGrid.Columns x:TypeArguments="syncfusion:Columns">
<syncfusion:GridTextColumn HeaderText="Order ID" 
MappingName="OrderID" />
<syncfusion:GridTextColumn HeaderText="Customer ID"
MappingName="CustomerID" />
<syncfusion:GridTextColumn MappingName="Customer" />
<syncfusion:GridTextColumn HeaderText="Ship Country"
MappingName="ShipCountry" />
</syncfusion:SfDataGrid.Columns>
</syncfusion:SfDataGrid>


{% endhighlight %}

The following code example illustrates about creating columns manually through C#.

{% highlight c# %}
dataGrid.AutoGenerateColumns = false;

GridTextColumn orderIdColumn = new GridTextColumn ();
orderIdColumn.MappingName = "OrderID";
orderIdColumn.HeaderText = "Order ID";

GridTextColumn customerIdColumn = new GridTextColumn ();
customerIdColumn.MappingName = "CustomerID";
customerIdColumn.HeaderText = "Customer ID";

GridTextColumn customerColumn = new GridTextColumn ();
customerColumn.MappingName = "Customer";

GridTextColumn countryColumn = new GridTextColumn ();
countryColumn.MappingName = "ShipCountry";
countryColumn.HeaderText = "Ship Country";

dataGrid.Columns.Add (orderIdColumn);
dataGrid.Columns.Add (customerIdColumn);
dataGrid.Columns.Add (customerColumn);
dataGrid.Columns.Add (countryColumn); 



{% endhighlight %}

{% endtabs %}

## Column Types – Forms 

This section explains you the different types of Column and the customizations that can done for a column.

**SfDataGrid** contains different types of columns each with its own functionalities as implied by its name. You can use any column based on your requirements. 

The below table describes you the types of columns and its purpose of usage in **SfDataGrid**.

<table>
<tr>
<th colspan=1 rowspan=1>Column Type<br/></th>
<th colspan=1 rowspan=1>Description<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>GridColumn<br/></td>
<td colspan=1 rowspan=1>Abstract class. Base column type of all the columns in the **SfDataGrid**.<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>GridTextColumn<br/></td>
<td colspan=1 rowspan=1>To be used to display string or numbers in each row.<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>GridSwitchColumn<br/></td>
<td colspan=1 rowspan=1>To be used when you want to display switch in each row.<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>GridImageColumn<br/></td>
<td colspan=1 rowspan=1>To be used when you want to display an image in each row.<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>GridTemplateColumn<br/></td>
<td colspan=1 rowspan=1>To be used when you want to customize your column based on your requirements.<br/></td>
</tr>
</table>

### GridColumn

GridColumn is the base column type of all the columns in the **SfDataGrid**, hence GridColumn properties are used by all the columns. The following sub-sections explains you about the properties in the GridColumn and the customizations that can be done using those properties for all the types of GridColums available in **SfDataGrid**.

#### Binding options

The display content of GridColumn is determined from GridColumn.DisplayBinding property. It gets and sets the binding that associates the GridColumn with a property in the data source. 

##### MappingName

GridColumn.MappingName associates the GridColumn with a property available in the underlying data source. While setting MappingName alone to the **SfDataGrid** the DisplayBinding will be automatically generated based on the MappingName. Data Manipulation operations like sorting, filtering, grouping will be done based on the MappingName property.

If you want to format the cell content, you can use the Converter of the GridColumn.DisplayBinding to customize the cell content. The following code example appends the text “Customer” along with the Customer ID.

{% tabs %}
{% highlight xml %}

<ContentPage.Resources>
<ResourceDictionary>
<local:DisplayBindingConverter x:Key="displayBindingConverter" />
</ResourceDictionary>
</ContentPage.Resources> 
<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrdersInfo}">

<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTextColumn MappingName="CustomerID" 
DisplayBinding="{Binding CustomerID, 
Converter={StaticResource displayBindingConverter}}" />
</syncfusion:SfDataGrid.Columns>

</syncfusion:SfDataGrid> 

{% endhighlight %}

{% highlight c# %}
public class DisplayBindingConverter : IValueConverter
{
public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
{
if (value != null)
return "Customer:" + value.ToString();
return null;
}

public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
{
return value.ToString().Substring(9);
}
}

{% endhighlight %}
{% endtabs %}



#### Header customizations

##### HeaderCellTextSize

The FontSize for the content of header cell in the GridColumn can be customized by using the GridColumn.HeaderCellTextSize property. The default font size of the header cells in **SfDataGrid** is 14.

##### HeaderFont

The FontFamily for the content of header cell in the GridColumn can be customized by using the GridColumn.HeaderFont property. The default value font used in **SfDataGrid** is “HelveticaNeue LT 55 Roman”.

##### HeaderFontAttribute

The FontAttribute for the content of the header cell in the GridColumn can be customized by using the GridColumn.HeaderFontAttribute property. The default value of this property is “None” and you can customize this to “Bold” or “Italic”.

##### HeaderText

**SfDataGrid** allows you to customize the display content of the header cell using the GridColumn.HeaderText property. It specifies the text displayed in the column header. If HeaderText is not defined, then GridColumn.MappingName will be assigned to the HeaderText and will be displayed as column header.

##### HeaderTextAlignment

You can get or set the TextAlignment of the header cell in the GridColumn by using the GridColumn.HeaderTextAlignment property. The default alignment for the header cells in **SfDataGrid** is “Center” and you can customize this to “Start” or “End”.

##### HeaderTemplate

**SfDataGrid** allows you to customize the header cell based on your requirement by using the GridColumn.HeaderTemplate property. The following code example shows you how to customize the header cell by loading a template in the header cell.

{% highlight xml %}

<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTextColumn MappingName="OrderID">
<syncfusion:GridTextColumn.HeaderTemplate>
<DataTemplate>
<Label x:Name="OrderID" Text="OrderID" TextColor="Black" 
BackgroundColor="Yellow" YAlign="Center" />
</DataTemplate>
</syncfusion:GridTextColumn.HeaderTemplate>
</syncfusion:GridTextColumn>
</syncfusion:SfDataGrid.Columns> 

{% endhighlight %}

#### Column Width

**SfDataGrid** allows you to customize the width of each GridColumn in the **SfDataGrid.Columns** collection. You can customize the column width by using the GridColumn.Width property. By default this property will not be assigned any value and the GridColumn renders in view based on the value of DefaultColumnWidth property in **SfDataGrid**.

### GridTextColumn

GridTextColumn is derived from GridColumn and hence it inherits all the properties of GridColumn. It is used to host the textual content in the record cells. Each of the record cells in GridTextColumn displays the text based on the Mapping Name that associates the column with a property in the data source.
The following code example creates GridTextColumn.
{% highlight xml %}

<syncfusion:GridTextColumn MappingName="OrderID" /> 

{% endhighlight %}

{% highlight c# %}

dataGrid.Columns.Add(new GridTextColumn() { MappingName = "OrderID" });

{% endhighlight %}

The below topics explain you about the customizations that can be done in the GridTextColumn in **SfDataGrid**.

#### Formatting

**SfDataGrid** allows you to format the value displayed in the GridColumn by using the GridColumn.Format property. Assign the FormatString to this property based on the type of the property the column is associated with to format the value. You can use different [StringFormats](http://msdn.microsoft.com/en-us/library/fbxft59x(v=vs.90).aspx) to customize the value displayed in the record cells.

The following code example shows you how to apply formatting for a GridTextColumn in XAML.

{% highlight xml %}

<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTextColumn MappingName="Freight" Format="C" />
<syncfusion:GridTextColumn MappingName="ShippingDate" Format="dd/MM/yyyy" />
</syncfusion:SfDataGrid.Columns> 

{% endhighlight %}

The following code example shows you how to apply formatting for a GridTextColumn in code.

{% highlight c# %}
dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "Freight",
Format = "C"
});

dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "ShippingDate",
Format = "dd/MM/yyyy"
});



{% endhighlight %}

N> For AutoGenerated columns the Formatting can be applied by handling the **SfDataGrid.AutoGeneratingColumn** event.

##### Formatting GridTextColumn with different Culture

**SfDataGrid** allows you to apply different [CultureInfo](https://developer.xamarin.com/api/type/System.Globalization.CultureInfo/) for the GridColumns by using the GridColumn.CultureInfo property. Assign the FormatString to this property based on the type of the property the column is associated with to format the value. You can use different [StringFormats](http://msdn.microsoft.com/en-us/library/fbxft59x\(v=vs.90\).aspx) to customize the value displayed in the record cells.
The following code example shows you how to apply different cultures for a GridColumns.
{% highlight c# %}
dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "Freight",
Format = "C",
CultureInfo = new CultureInfo("en-US")
});

dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "OrderID",
Format = "C",
CultureInfo = new CultureInfo("en-GB")
}); 



{% endhighlight %}

For auto generated columns this is achievable by handling the **SfDataGrid.AutoGeneratingColumn** event. The following code example shows you how to apply different cultures for auto generated GridColumns.
{% highlight c# %}
void GridAutoGeneratingColumns(object sender, AutoGeneratingColumnArgs e)
{
if (e.Column.MappingName == "Freight") {
e.Column.Format = "C";
e.Column.CultureInfo = new CultureInfo ("en-US");
} else if (e.Column.MappingName == "OrderID") {
e.Column.Format = "C";
e.Column.CultureInfo = new CultureInfo ("en-GB");
}
} 



{% endhighlight %}

#### Font and Alignment options

CellTextSize
The FontSize for the content of record cells in GridColumn can be customized by using the GridColumn.CellTextSize property. The default font size of the record cells in **SfDataGrid** is 14.
RecordFont
The FontFamily for the content of header cell in the GridColumn can be customized by using the GridColumn.RecordFont property. The default value font used in **SfDataGrid** is “Helvetica Neue”.
TextAlignment
You can get or set the TextAlignment of the header cell in the GridColumn by using the GridColumn.TextAlignment property. The default alignment for the record cells in **SfDataGrid** is “Center” and you can customize this to “Start” or “End”.
TextWrapping
When the text for the record cells exceeds the content area, you can use the GridColumn.TextWrapping property to wrap the cell content.

### GridSwitchColumn

GridSwitchColumn is derived from GridColumn, and hence it inherits all the properties of GridColumn. It loads a switch as a content of record cells in the column and responds to value changes in it. You can change the underlying data source that toggles the values shown in the switch.
The following code example shows how to use GridSwitchColumn. 
{% highlight xml %}

<syncfusion:GridSwitchColumn MappingName="IsClosed" />  



{% endhighlight %}

{% highlight c# %}

dataGrid.Columns.Add(new GridSwitchColumn() { MappingName = "IsClosed" }); 



{% endhighlight %}

### GridImageColumn

GridImageColumn is derived from GridColumn, and hence it inherits all the properties of GridColumn. It displays images which as content of record cells in the column. The images loaded inside this column should be added as EmbeddedResource.
The following code example shows how to use GridImageColumn. 
{% highlight xml %}

<syncfusion:GridImageColumn MappingName="DealerImage" />  



{% endhighlight %}

{% highlight c# %}

dataGrid.Columns.Add(new GridImageColumn() { MappingName = "DealerImage" });  



{% endhighlight %}

{% endtabs %}### GridTemplateColumn

GridTemplateColumn is derived from GridColumn, and hence it inherits all the properties of GridColumn. It allows you to extend the functionality of GridColumns with your own view by creating the CellTemplate of GridTemplateColumn.
The below table provides the list of properties in GridTemplateColumn.
<table>
<tr>
<th colspan=1 rowspan=1>Property<br/></th>
<th colspan=1 rowspan=1>Type<br/></th>
<th colspan=1 rowspan=1>Description<br/></th>
<th colspan=1 rowspan=1>Default Value<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>CellTemplate<br/></td>
<td colspan=1 rowspan=1>DataTemplate <br/></td>
<td colspan=1 rowspan=1>Gets or sets the template that is used to display the contents of the record cells.<br/></td>
<td colspan=1 rowspan=1>Null<br/></td>
</tr>
</table>

The following code example shows templating of GridTemplateColumn. Underlying record will be the BindingContext for the CellTemplate.

{% tabs %}{% highlight xml %}

<syncfusion:GridTemplateColumn MappingName="CustomerID">
<syncfusion:GridTemplateColumn.CellTemplate>
<DataTemplate>
<Label Text="{Binding CustomerID}" TextColor="Black" 
XAlign="Center" YAlign="Center" />
</DataTemplate>
</syncfusion:GridTemplateColumn.CellTemplate>
</syncfusion:GridTemplateColumn> 



{% endhighlight %}

The **SfDataGrid** allows you to extend the functionality of GridColumns with your own view by using the CellTemplate of the GridTemplateColumn. The following code example illustrates how template column can be used to load a stock cell inside it.

{% highlight xml %}
<ContentPage.Resources>
<ResourceDictionary>
<local:ImageConverter x:Key="imageConverter" /> 
</ResourceDictionary>
</ContentPage.Resources>

<ContentPage.ContentView>
<syncfusion:SfDataGrid x:Name="dataGrid"
ColumnSizer="Star">

<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTemplateColumn HeaderText="Stock Change"
MappingName="StockChange">
<syncfusion:GridTemplateColumn.CellTemplate>
<DataTemplate>
<Grid>
<Grid.ColumnDefinitions>
<ColumnDefinition Width="Auto" />
<ColumnDefinition Width="*" />
</Grid.ColumnDefinitions>
<Image Grid.Column="0"
Source="{Binding StockChange,
Converter={StaticResource imageConverter}}" />
<Label x:Name="changeValue" Grid.Column="1"
Text="{Binding StockChange}" TextColor="Black"
XAlign="Center" YAlign="Center">
</Label>
</Grid>
</DataTemplate>
</syncfusion:GridTemplateColumn.CellTemplate>
</syncfusion:GridTemplateColumn>
</syncfusion:SfDataGrid.Columns>
</syncfusion:SfDataGrid>
</ContentPage.ContentView> 



{% endhighlight %}

In order to get the above code example working, you need to write a converter to load the images inside grid cell based on the CellValue. The images that has to be loaded inside the GridCell must be added as EmbeddedResource.
The following code example shows you converter code for loading the images in a template column.
{% highlight c# %}

public class ImageConverter:IValueConverter
{
public object Convert (object value, Type targetType, object parameter, CultureInfo culture)
{
var data = value as double?;
if (data != null && data > 0)
return ImageSource.FromResource("DataGridSample.Icons.Green.png");
else
return ImageSource.FromResource("DataGridSample.Icons.Red.png");
}
public object ConvertBack (object value, Type targetType, object parameter, CultureInfo culture)
{
throw new NotImplementedException ();
}
} 



{% endhighlight %}

{% endtabs %}## Column Types – Android & iOS

This section explains you the different types of Column and the customizations that can done for a column.

**SfDataGrid** contains two types of columns each with its own functionalities. You can use any column based on your requirements.
 
The below table describes you the types of columns and its purpose of usage in **SfDataGrid**.

<table>
<tr>
<th colspan=1 rowspan=1>Column Type<br/></th>
<th colspan=1 rowspan=1>Description<br/></th>
</tr>
<tr>
<td colspan=1 rowspan=1>GridColumn<br/></td>
<td colspan=1 rowspan=1>Abstract class. Base column type of all the columns in the **SfDataGrid**.<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>GridTextColumn<br/></td>
<td colspan=1 rowspan=1>To be used to display string or numbers in each row.<br/></td>
</tr>
<tr>
<td colspan=1 rowspan=1>TemplateColumn (i.e. GridTextColumn with UserCellType)<br/></td>
<td colspan=1 rowspan=1>To be used when you want to customize your column based on your requirements.<br/></td>
</tr>
</table>

### GridColumn

GridColumn is the base column type of all the columns in the **SfDataGrid**, hence GridColumn properties are used by all the columns. The following sub-sections explains you about the properties in the GridColumn and the customizations that can be done using those properties.

#### MappingName

**GridColumn.MappingName** associates the GridColumn with a property available in the underlying data source. While setting MappingName alone to the **SfDataGrid**, DisplayBinding will be automatically generated based on the MappingName. Data Manipulation operations like sorting, filtering, grouping will be done based on the MappingName property.

#### Header customizations

##### HeaderCellTextSize

The FontSize for the content of header cell in the GridColumn can be customized by using the GridColumn.HeaderCellTextSize property. The default font size of the header cells in **SfDataGrid** is 14.

##### HeaderFont

The FontFamily for the content of header cell in the GridColumn can be customized by using the GridColumn.HeaderFont property. The default value font used in **SfDataGrid** is “Roboto-Bold” for Android and “Helvetica-Bold” in iOS.

##### HeaderText

GridColumn.HeaderText specifies the text displayed in the column header. If HeaderText is not defined, the GridColumn.MappingName will be assigned to the HeaderText and will be displayed as column header.

##### HeaderTextAlignment
You can get or set the TextAlignment of the header cell in the GridColumn by using the GridColumn.HeaderTextAlignment property. The default alignment for the header cells in **SfDataGrid** is “Center”.

### GridTextColumn

GridTextColumn is derived from GridColumn and hence it inherits all the properties of GridColumn. Each of the record cells in GridTextColumn displays text based on the Mapping Name which associates the column with a property in the data source.
The following code example creates GridTextColumn.
{% tabs %}{% highlight c# %}
dataGrid.Columns.Add(new GridTextColumn() { MappingName = "OrderID" });



{% endhighlight %}

The below topics explain you about the customizations that can be done in the GridTextColumn in **SfDataGrid**.

#### Formatting

**SfDataGrid** allows you to format the value displayed in the GridColumn by using the **GridColumn.Format** property. Assign the FormatString to this property based on the type of the property the column is associated with to format the value. You can use different [StringFormats](http://msdn.microsoft.com/en-us/library/fbxft59x\(v=vs.90\).aspx) to customize the value displayed in the record cells.

The following code example shows you how to apply formatting for a GridTextColumn in code.

{% highlight c# %}
dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "Freight",
Format = "C"
});

dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "ShippingDate",
Format = "dd/MM/yyyy"
});



{% endhighlight %}

Note: For AutoGenerated columns the Formatting can be applied by handling the **SfDataGrid.AutoGeneratingColumn** event.
##### Formatting GridTextColumn with different Culture

**SfDataGrid** allows you to apply different [CultureInfo](https://developer.xamarin.com/api/type/System.Globalization.CultureInfo/) for the GridColumns by using the GridColumn.CultureInfo property. Assign the FormatString to this property based on the type of the property the column is associated with to format the value. You can use different [StringFormats](http://msdn.microsoft.com/en-us/library/fbxft59x\(v=vs.90\).aspx) to customize the value displayed in the record cells.
The following code example shows you how to apply different cultures for a GridColumns.
{% highlight c# %}
dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "Freight",
Format = "C",
CultureInfo = new CultureInfo("en-US")
});

dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "OrderID",
Format = "C",
CultureInfo = new CultureInfo("en-GB")
}); 



{% endhighlight %}

For auto generated columns this is achievable by handling the **SfDataGrid.AutoGeneratingColumn** event. The following code example shows you how to apply different cultures for auto generated GridColumns.
{% highlight c# %}
void GridAutoGeneratingColumns(object sender, AutoGeneratingColumnArgs e)
{
if (e.Column.MappingName == "Freight") {
e.Column.Format = "C";
e.Column.CultureInfo = new CultureInfo ("en-US");
} else if (e.Column.MappingName == "OrderID") {
e.Column.Format = "C";
e.Column.CultureInfo = new CultureInfo ("en-GB");
}
} 



{% endhighlight %}

#### Font and Alignment options

CellTextSize
The FontSize for the content of record cells in GridColumn can be customized by using the GridColumn.CellTextSize property. The default font size of the record cells in **SfDataGrid** is 14.
RecordFont
The FontFamily for the content of header cell in the GridColumn can be customized by using the GridColumn.RecordFont property. The default value font used in **SfDataGrid** is “Roboto-Regular” for Android and “HelveticaNeue” for iOS.
TextAlignment
You can get or set the TextAlignment of the header cell in the GridColumn by using the GridColumn.TextAlignment property. The default alignment for the record cells in **SfDataGrid** is “Center”.
### TemplateColumn

TemplateColumn is actually the GridTextColumn with UserCellType specified and hence it inherits all the properties of GridColumn. It allows you to extend the functionality of GridColumns with your own view by creating custom GridCell to render in the column.
The following code example shows how to create a TemplateColumn.
{% highlight c# %}

GridTextColumn customerIdColumn = new GridTextColumn ();
customerIdColumn.UserCellType = typeof(CustomCell);
customerIdColumn.MappingName = "CustomerID";
customerIdColumn.HeaderText = "Customer ID";  



{% endhighlight %}

In order to create a template column in **SfDataGrid**, you need to specify the UserCellType of the column. UserCellType is the type of the view to be used in the GridColumn and it must be derived from the GridCell. (i.e. a custom GridCell which hosts the view of your own requirement). 
The following code example shows you how to create a custom GridCell and use it in a template column.
{% highlight c# %}
//Creating a Template Column 
GridTextColumn customerIdColumn = new GridTextColumn ();
customerIdColumn.UserCellType = typeof(CustomCell);
customerIdColumn.MappingName = "CustomerID";
customerIdColumn.HeaderText = "Customer ID"; 
//Creating Custom GridCell in Android 
public class CustomCell : GridCell
{
TextView textView;

public CustomCell (Context context) : base (context)
{
textView = new TextView (this.Context);
this.AddView (textView);
this.CanRenderUnLoad = false;
}

protected override void UnLoad ()
{
if (this.Parent != null)
(this.Parent as VirtualizingCellsControl).RemoveView (this);
}

protected override void OnLayout(bool change, int l, int t, int r, int b)
{
this.textView.Layout (0, 0, this.Width, this.Height);
}

protected override void OnDraw (Canvas canvas)
{
base.OnDraw (canvas);
this.textView.Text = DataColumn.CellValue.ToString ();
}
}
//Creating Custom GridCell in iOS
public class CustomCell : GridCell
{
UILabel label;

public CustomCell ()
{
label = new UILabel ();
this.Add (label);
this.CanRenderUnLoad = false;
}

protected override void UnLoad ()
{
this.RemoveFromSuperview (this);
}

protected override void LayoutSubviews ()
{
base.LayoutSubviews ();
this.label.Frame (Bounds.Left, Bounds.Top, Bounds.Width, Bounds.Height);
this.label.Text = DataColumn.CellValue.ToString ();
}
}



{% endhighlight %}

## Sorting 

This section explains you about Sorting the data and about the properties and events that involve in Sorting in **SfDataGrid**. 
**SfDataGrid** allows you to apply sorting on its data by setting the **SfDataGrid.AllowSorting** property to true. It allows you to sort the data against one or more columns. When sorting is applied, the Grid automatically rearranges the data to match with the current sort criteria. When **SfDataGrid.AllowSorting** is true, you can sort the data simply by tapping the column header you wish to sort. Once sorting is applied, the Grid shows a sort icon in the respective column header indicating the direction of sorting.
### Programmatic Sorting

**SfDataGrid** also allows to perform sorting from the code. This requires you to manually define the SortColumnDescription objects and add it in the **SfDataGrid.SortColumnDescriptions** collection. **SfDataGrid** sorts the data based on the SortColumnDescription objects that are added to this collection.
SortColumnDescription object holds following two properties:
* ColumnName: Name of the sorted column.

* SortDirection: An object of type ListSortDirection defines the sorting direction.


The following code example illustrates this.
{% highlight c# %}
dataGrid.AllowSorting = true;

dataGrid.SortColumnDescriptions.Add (new SortColumnDescription () {
ColumnName = "OrderID",
SortDirection = ListSortDirection.Descending
}); 



{% endhighlight %}

{% highlight xml %}

<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrdersInfo}">

<syncfusion:SfDataGrid.SortColumnDescriptions>
<syncfusion:SortColumnDescription ColumnName="OrderID" 
SortDirection="Descending" />
</syncfusion:SfDataGrid.SortColumnDescriptions>
</syncfusion:SfDataGrid> 



{% endhighlight %}

### Tri-State Sorting

In addition to sort the data in ascending / descending orders, **SfDataGrid** also allows you to unsort the data in the original order by clicking the header again after sorting to descending order by setting the **SfDataGrid.AllowTriStateSorting** property to true. When this property is set Sorting in each column iterates through three sort states; ascending, descending, and unsorted.
The following code example shows how to enable Tri-State sorting in **SfDataGrid**.
{% highlight c# %}
dataGrid.AllowTriStateSorting = true;



{% endhighlight %}

{% highlight xml %}

<syncfusion:SfDataGrid AllowTriStateSorting="True" />



{% endhighlight %}

### Multi Sorting

**SfDataGrid** allows you to sort the data against more than one columns by setting the **SfDataGrid.AllowMultiSort** property to true. The number of columns by which the data can be sorted is unlimited. To apply sorting for multiple columns, tap the desired column headers after setting the **SfDataGrid.AllowMultiSort** property.

The following code example shows how to enable multi-sorting in **SfDataGrid**.

{% highlight c# %}

dataGrid.AllowMultiSort = true;

{% endhighlight %}

{% highlight xml %}

<syncfusion:SfDataGrid AllowMultiSort="True" />



{% endhighlight %}

### Sorting Events

The **SfDataGrid** provides you the following Events for the sorting functionality:
* SortColumnsChanging – This Event is raised while sorting the column at execution time before the column gets sorted. It helps to cancel the sorting action by setting the Cancel property of DataGridSortColumnsChangingEventArgs.

* SortColumnsChanged – This Event is raised after the column is sorted.


These two events are triggered with DataGridSortColumnsChangingEventArgs and DataGridSortColumnsChangedEventArgs that contain the following properties.
* AddedItems – Gets the collection of SortColumnDescription objects that are added to **SfDataGrid.SortColumnDescriptions** collection for Sorting.

* RemovedItems – Gets the collection of SortColumnDescription objects that are removed from **SfDataGrid.SortColumnDescriptions** collection.


The following code example illustrates how to hook the SortColumnsChanging event and cancel the sorting of a column.
{% highlight c# %}
dataGrid.SortColumnsChanging += DataGrid_SortColumnsChanging; 

void DataGrid_SortColumnsChanging (object sender, DataGridSortColumnsChangingEventArgs e)
{
if(e.AddedItems[0].ColumnName == "OrderID")
{
e.Cancel = true;
}
}  



{% endhighlight %}

{% highlight xml %}

<syncfusion:SfDataGrid x:Name="dataGrid"
AllowSorting="True"
SortColumnsChanging="DataGrid_SortColumnsChanging"
ItemsSource="{Binding OrdersInfo}">
</syncfusion:SfDataGrid> 



{% endhighlight %}

### Custom sorting

**SfDataGrid** allows you to sort columns based on custom logic when the standard sorting techniques do not meet the requirements. For each column, you can apply different sorting criteria by adding SortComparer objects to **SfDataGrid.SortComparersCollection**.
A SortComparer object has the following properties:
* PropertyName: MappingName of the column that applies custom sorting.

* Comparer: Gets or sets the custom comparer that implements the IComparer and ISortDirection interfaces.


The following code example illustrates how to perform custom sorting for FirstName column based on the string length of the names.
{% highlight c# %}
dataGrid.SortComparers.Add (new SortComparer () {
PropertyName = "FirstName",
Comparer = new CustomComparer()
});

dataGrid.SortColumnDescriptions.Add (new SortColumnDescription () {
ColumnName = "FirstName",
SortDirection = ListSortDirection.Descending
}); 



{% endhighlight %}

{% highlight xml %}

<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:data="clr-namespace:Syncfusion.Data;assembly=Syncfusion.Data.Portable"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms"
xmlns:local ="clr-namespace:DataGridSample;assembly=DataGridSample"
x:Class="DataGridSample.Sample">

<ContentPage.Resources>
<ResourceDictionary>
<local:CustomerInfo x:Key="Comparer" />
</ResourceDictionary>
</ContentPage.Resources>

<ContentPage.BindingContext>
<local:ViewModel x:Name="viewModel" />
</ContentPage.BindingContext>

<syncfusion:SfDataGrid x:Name="dataGrid"
AllowSorting="True"
ItemsSource="{Binding OrdersInfo}">

<syncfusion:SfDataGrid.SortComparers>
<data:SortComparer Comparer="{StaticResource Comparer}"
PropertyName="FirstName" />
</syncfusion:SfDataGrid.SortComparers>

<syncfusion:SfDataGrid.SortColumnDescriptions>
<syncfusion:SortColumnDescription ColumnName="FirstName" 
SortDirection="Descending" />
</syncfusion:SfDataGrid.SortColumnDescriptions>
</syncfusion:SfDataGrid>
</ContentPage> 



{% endhighlight %}

The following code example illustrates the Custom Comparer.
{% highlight c# %}
public class CustomerInfo : IComparer<Object>, ISortDirection
{
public int Compare(object x, object y)
{
int namX;
int namY;

//For OrderInfo type data
if (x.GetType () == typeof(OrderInfo)) {
//Calculating the length of FirstName in OrderInfo objects
namX = ((OrderInfo)x).FirstName.Length;
namY = ((OrderInfo)y).FirstName.Length;
}

//For Group type data                                   
else if (x.GetType () == typeof(Group)) {
//Calculating the group key length
namX = ((Group)x).Key.ToString ().Length;
namY = ((Group)y).Key.ToString ().Length;
} else {
namX = x.ToString ().Length;
namY = y.ToString ().Length;
}

// Objects are compared and return the SortDirection
if (namX.CompareTo (namY) > 0)
return SortDirection == ListSortDirection.Ascending ? 1 : -1;
else if (namX.CompareTo (namY) == -1)
return SortDirection == ListSortDirection.Ascending ? -1 : 1;
else
return 0; 
}

//Gets or sets the SortDirection value
public ListSortDirection SortDirection {
get;
set;
}
} 



{% endhighlight %}

### Disable sorting for an individual column

**SfDataGrid** allows you to disable the sorting for individual columns by using the GridColumn.AllowSorting property. The default value of this property is true and hence all the columns in the **SfDataGrid.Columns** collection can be sorted when **SfDataGrid.AllowSorting** is set to true.
## Grouping 

This section explains you how to group a column in **SfDataGrid** and about the properties and customizations available for Grouping in **SfDataGrid**.
A Group represents a collection of records that belong to a particular category. When Grouping is applied, the data is organized into a hierarchical structure based on matching field values. The records having identical values in the grouped column are combined to form a Group. Each Group is identified by its CaptionSummaryRow to get the underlying records in view. 
### Programmatic Grouping

**SfDataGrid** also allows to perform grouping from the code by defining the GroupColumnDescription object and adding it in the **SfDataGrid.GroupColumnDescriptions** collection. **SfDataGrid** groups the data based on the GroupColumnDescription object that is added to this collection.
GroupColumnDescription object holds following two properties:
* ColumnName: Name of the grouped column.

* Converter: Get the IValueConverter as input that helps to apply the custom grouping.


The following code example illustrates how to apply grouping by a column in **SfDataGrid**.
{% highlight c# %}
dataGrid.GroupColumnDescriptions.Add (new GroupColumnDescription () {
ColumnName = "CustomerID",
}); 



{% endhighlight %}

{% highlight xml %}

<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrdersInfo}">

<syncfusion:SfDataGrid.GroupColumnDescriptions>
<syncfusion:GroupColumnDescription ColumnName="CustomerID" />
</syncfusion:SfDataGrid.GroupColumnDescriptions>
</syncfusion:SfDataGrid> 



{% endhighlight %}

### Custom Grouping

**SfDataGrid** allows you to group a column based on custom logic when the standard grouping techniques do not meet the requirements. To achieve the CustomGrouping, you need to write a converter that implements IValueConverter with your CustomGrouping logic and assign that converter to the GroupColumnDescription.Converter property.
The following code example illustrates how to set the custom grouping converter for the group description that is added to group the Freight column.
{% highlight c# %}
dataGrid.GroupColumnDescriptions.Add (new GroupColumnDescription () {
ColumnName = "Freight",
Converter = new GroupConverter()
}); 



{% endhighlight %}

{% highlight xml %}

<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms"
xmlns:local ="clr-namespace:DataGridSample;assembly=DataGridSample"
x:Class="DataGridSample.Sample">

<ContentPage.Resources>
<ResourceDictionary>
<local:GroupConverter x:Key="groupConverter" />
</ResourceDictionary>
</ContentPage.Resources>

<ContentPage.BindingContext>
<local:ViewModel x:Name="viewModel" />
</ContentPage.BindingContext>

<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrdersInfo}">

<syncfusion:SfDataGrid.GroupColumnDescriptions>
<syncfusion:GroupColumnDescription ColumnName="Freight"
Converter="{StaticResource groupConverter}" />
</syncfusion:SfDataGrid.GroupColumnDescriptions>
</syncfusion:SfDataGrid>
</ContentPage> 



{% endhighlight %}

The following code example illustrates the converter used for applying CustomGrouping logic.
{% highlight c# %}
public class GroupConverter : IValueConverter
{
public GroupConverter()
{

}
public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
{
var orderInfo = value as OrderInfo;
if (orderInfo.Freight > 0 && orderInfo.Freight <= 250)
return "<=250";
else if (orderInfo.Freight > 250 && orderInfo.Freight <= 500)
return ">250 & <=500";
else if (orderInfo.Freight > 500 && orderInfo.Freight <= 750)
return ">500 & <=750";
else
return ">1000";
}

public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
{
return null;
}
} 



{% endhighlight %}

### How To

#### How to hide the grouped column in SfDataGrid?

In **SfDataGrid** a column will be generated with the default column width by default. In order to group by a column that should not be visible in view, add the column to the **SfDataGrid.Columns** collection and set its width as 0. Thus the column will be grouped and will not be visually seen. Please refer the below code example.
{% highlight c# %}
dataGrid.Columns.Add (new GridTextColumn () { 
MappingName = "ShippingDate",
Width = 0
});

dataGrid.GroupColumnDescriptions.Add (new GroupColumnDescription () { 
ColumnName = "ShippingDate"
}); 



{% endhighlight %}

{% highlight xml %}

<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTextColumn MappingName="ShippingDate" Width="0" />
</syncfusion:SfDataGrid.Columns>

<syncfusion:SfDataGrid.GroupColumnDescriptions>
<syncfusion:GroupColumnDescription ColumnName="ShippingDate" />
</syncfusion:SfDataGrid.GroupColumnDescriptions> 



{% endhighlight %}

## Summary

This section explains you how to show the summarizing information of grouped data and how to customize the format of the summary information in **SfDataGrid**.
**SfDataGrid** displays the summaries for each Group using the CaptionSummaryRow. The CaptionSummaryRow carries the information about a particular Group like the Group name, number of items (records) in the Group, etc.
**SfDataGrid** also supports setting custom GroupCaptionTextFormat for CaptionSummaryRows. By default the group caption text will be in the format "{ColumnName} : {Key} - {ItemsCount} Items". 
* ColumnName : Displays the grouped column name.

* Key : Displays the group key value.

* ItemsCount : Displays the number of items in group.


You can customize this group caption text format by setting the **SfDataGrid.GroupCaptionTextFormat** property. The following code example illustrates how to customize GroupCaptionText in **SfDataGrid**.
{% highlight c# %}
//Customized GroupCaptionText in German
dataGrid.GroupCaptionTextFormat = "{ColumnName} : {Key} - {ItemsCount} Produkte"; 



{% endhighlight %}

## Filtering – Forms 

**SfDataGrid** provides support to filter the records in view by setting the **SfDataGrid.View.Filter** property. You have to call the **SfDataGrid.View.RefreshFilter()** method after assigning the Filter property for refreshing the view. 
The following code example illustrates how to apply filtering in **SfDataGrid**. FilterRecords method filters the data that contains the filterText value. Assign FilterRecords method to **SfDataGrid.View.Filter** predicate to filter the CustomerID column.
{% highlight xml %}
//Filtering.xaml

<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms"
xmlns:local ="clr-namespace:DataGridSample;assembly=DataGridSample"
x:Class="DataGridSample.Sample">

<ContentPage.BindingContext>
<local:ViewModel x:Name="viewModel" />
</ContentPage.BindingContext>

<Grid>
<Grid.RowDefinitions>
<RowDefinition Height="50" />
<RowDefinition Height="*" />
</Grid.RowDefinitions>

<SearchBar Placeholder="Search CustomerID" 
TextChanged="searchBar_TextChanged" />

<syncfusion:SfDataGrid x:Name="dataGrid"
Grid.Row="1"
ItemsSource="{Binding OrdersInfo}" />
</Grid>
</ContentPage> 



{% endhighlight %}

{% highlight c# %}
//Filtering.xaml.cs
viewModel.FilterTextChanged = OnFilterChanged;  
private void searchBar_TextChanged(object sender, TextChangedEventArgs e)
{
if (e.NewTextValue == null)
viewModel.FilterText = "";
else
viewModel.FilterText = e.NewTextValue;
}

private void OnFilterChanged()
{
if (dataGrid.View != null) {
this.dataGrid.View.Filter = viewModel.FilerRecords;
this.dataGrid.View.RefreshFilter ();
}
} 



{% endhighlight %}

The following code example illustrates the code for filtering the data using FilterRecords method in the ViewModel.
{% highlight c# %}
//ViewModel.cs
internal delegate void FilterChanged();

internal FilterChanged FilterTextChanged;

private string filterText = "";

public string FilterText {
get { return filterText; }
set {
filterText = value;
OnFilterTextChanged ();
RaisePropertyChanged ("FilterText");
}
}

private void OnFilterTextChanged()
{
if (FilterTextChanged != null)
FilterTextChanged ();
}

public bool FilerRecords(object order)
{
var item = order as OrderInfo;
if (item != null && FilterText.Equals ("") && !string.IsNullOrEmpty (FilterText))
return true;
else if (item != null) {
var exactValue = item.CustomerID.ToLower ();
string text = FilterText.ToLower ();
return exactValue.Contains (text);
}
return false;
} 



{% endhighlight %}

## Filtering – Android & iOS 

**SfDataGrid** provides support to filter the records in view by setting the **SfDataGrid.View.Filter** property. You have to call the **SfDataGrid.View.RefreshFilter()** method after assigning the Filter property for the records to get filtered in view. 
The following code example illustrates how to apply filtering in **SfDataGrid**. FilterRecords method filters the data that contains the filterText value. Assign FilterRecords method to **SfDataGrid.View.Filter** predicate to filter the CustomerID column. 
{% highlight c# %}
//For Android: 
SearchView filterText = new SearchView(BaseContext);
filterText.SetQueryHint ("Search CustomerID");
filterText.QueryTextChange += OnFilterTextChanged;
viewModel.FilterTextChanged = OnFilterChanged; 
void OnFilterTextChanged(object sender, SearchView.QueryTextChangeEventArgs e)
{
viewModel.FilterText = (sender as SearchView).Query.ToString();
} 
private void OnFilterChanged()
{
if (dataGrid.View != null) {
this.dataGrid.View.Filter = viewModel.FilerRecords;
this.dataGrid.View.RefreshFilter ();
}
}
//For iOS: 
UISearchBar filterText = new UISearchBar ();
filterText.TextChanged += OnFilterTextChanged;
filterText.Placeholder = "Search CustomerID"; 
viewModel.FilterTextChanged = OnFilterChanged;
void OnFilterTextChanged(object sender, UISearchBarTextChangedEventArgs e)
{
viewModel.FilterText = e.SearchText;
} 
private void OnFilterChanged()
{
if (dataGrid.View != null) {
this.dataGrid.View.Filter = viewModel.FilerRecords;
this.dataGrid.View.RefreshFilter ();
}
}



{% endhighlight %}

The following code example illustrates the code for filtering the data using FilterRecords method in the ViewModel.
{% highlight c# %}
//ViewModel.cs: 
internal delegate void FilterChanged();

internal FilterChanged FilterTextChanged;

private string filterText = "";

public string FilterText {
get { return filterText; }
set {
filterText = value;
OnFilterTextChanged ();
RaisePropertyChanged ("FilterText");
}
}

private void OnFilterTextChanged()
{
if (FilterTextChanged != null)
FilterTextChanged ();
}

public bool FilerRecords(object order)
{
var item = order as OrderInfo;
if (item != null && FilterText.Equals ("") && !string.IsNullOrEmpty (FilterText))
return true;
else if (item != null) {
var exactValue = item.CustomerID.ToLower ();
string text = FilterText.ToLower ();
return exactValue.Contains (text);
}
return false;
} 



{% endhighlight %}

## Selection

This section explains you about how to enable selection in **SfDataGrid** and about the selection modes, properties, events that involve in selection and customizations available for Selection in **SfDataGrid**.

**SfDataGrid** lets you to select a specific row or group of rows either programmatically or by touch interactions. To enable Selection in **SfDataGrid**, you need to set the **SfDataGrid.SelectionMode** property to value other than “None”. **SfDataGrid** has different selection modes to perform selection operation as listed below.

* None: Disables selection and no rows can be selected. This is the default value.

* Single: Allows you to select a single row only. Upon selecting the next row the selection in the previous row is cleared.

* Multiple: Allows you to select more than one row. Selection is not cleared when selecting more than one records. When you click on a selected row for the second time, selection is cleared.

* SingleDeselect: Allows you to select only a single row, however upon tapping the row again the Selection is cleared. Similar to “Single” mode, upon selecting the next row the selection in the previous row is cleared.


The following code example illustrates how to set the selection mode in **SfDataGrid**.
{% highlight c# %}
dataGrid.SelectionMode = SelectionMode.Single; 



{% endhighlight %}

### Programmatic Selection

When **SfDataGrid.SelectionMode** is set a value other than “None”, you can also select the row / rows in **SfDataGrid** from the code by setting the **SfDataGrid.SelectedIndex**, **SfDataGrid.SelectedItem** or **SfDataGrid.SelectedItems** property based on the selection mode. The following code example illustrates how to enable selection from code in **SfDataGrid**.
When the selection mode is “Single” you can programmatically select a row in two ways, either by setting the row index to the **SfDataGrid.SelectedIndex** property or by setting the underlying object to be selected to the **SfDataGrid.SelectedItem** property. 
The following code example illustrates how to programmatically select a row from the code.
{% highlight c# %}
//Perform selection using selected index
dataGrid.SelectedIndex = 3; 
//Perform selection using selected item
dataGrid.SelectedItem = viewModel.OrdersInfo [5];  



{% endhighlight %}

### Selection Events

The **SfDataGrid** provides you the following Events for Selection:
* SelectionChanging – This Event is raised while selecting a row at the execution time before the row is selected. Hence it allows you to cancel the selection action by setting the Cancel property of GridSelectionChangingEventArgs.

* SelectionChanged – This Event is raised after the column is selected.


These two events are triggered with GridSelectionChangingEventArgs and GridSelectionChangedEventArgs that contain the following properties.
* AddedItems – Gets the collection of underlying data objects that are added for selection.

* RemovedItems – Gets the collection of underlying data objects that are removed selection.


The following code example illustrates how to hook the SelectionChanging event and cancel the selection of a column.
{% highlight c# %}
dataGrid.SelectionChanging += DataGrid_SelectionChanging;  

void DataGrid_SelectionChanging (object sender, GridSelectionChangingEventArgs e)
{
e.Cancel = true;
} 



{% endhighlight %}

### Clear Selection

**SfDataGrid** allows you to clear the selection applied in the grid rows in two ways, either by setting the **SfDataGrid.SelectionMode** to “None” or by calling the **SfDataGrid.SelectionController.ClearSelection()** method.
The following code example illustrates how to clear selection in **SfDataGrid**.
{% highlight c# %}
//Clear selection using selection mode
dataGrid.SelectionMode = SelectionMode.None;

//Clear selection using selection controller
dataGrid.SelectionController.ClearSelection (); 



{% endhighlight %}

## Styles

This section explains you about how to apply styles for changing the visual appearance of the **SfDataGrid** and its elements.
**SfDataGrid** allows you to apply style to all of its elements by writing a Style class overriding from DataGridStyle and assigning it to the **SfDataGrid.GridStyle** property.  
The following example explains you how to apply custom style to **SfDataGrid**.
{% highlight c# %}
//Apply custom style to **SfDataGrid** from code
dataGrid.GridStyle = new Dark (); 


{% endhighlight %}

{% highlight xml %}

<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms"
xmlns:local ="clr-namespace:DataGridSample;assembly=DataGridSample"
x:Class="DataGridSample.Sample">

<ContentPage.Resources>
<ResourceDictionary>
<local:Dark x:Key="dark" />
</ResourceDictionary>
</ContentPage.Resources>

<syncfusion:SfDataGrid x:Name="dataGrid"
GridStyle="{StaticResource dark}"
ItemsSource="{Binding OrdersInfo}" />
</ContentPage> 



{% endhighlight %}

{% highlight c# %}
//Custom style class
public class Dark : DataGridStyle
{
public Dark ()
{
}

public override Color GetHeaderBackgroundColor()
{
return Color.FromRgb (15, 15, 15);
}

public override Color GetHeaderForegroundColor()
{
return Color.FromRgb (255, 255, 255);
}

public override Color GetRecordBackgroundColor ()
{
return Color.FromRgb (43, 43, 43);
}

public override Color GetRecordForegroundColor ()
{
return Color.FromRgb (255, 255, 255);
}

public override Color GetSelectionBackgroundColor ()
{
return Color.FromRgb (42, 159, 214);
}

public override Color GetSelectionForegroundColor ()
{
return Color.FromRgb (255, 255, 255);
}

public override Color GetCaptionSummaryRowBackgroundColor ()
{
return Color.FromRgb (02, 02, 02);
}

public override Color GetCaptionSummaryRowForeGroundColor ()
{
return Color.FromRgb (255, 255, 255);
}

public override Color GetBordercolor ()
{
return Color.FromRgb (81, 83, 82);
}

public override Color GetLoadMoreViewBackgroundColor ()
{
return Color.FromRgb(242, 242, 242);
}

public override Color GetLoadMoreViewForegroundColor ()
{
return Color.FromRgb(34, 31, 31);
}
} 



{% endhighlight %}

## Conditional styles - Forms

**SfDataGrid** allows you apply cell styles for a GridColumn that is used to render the cells in that column. When applied cell style the GridCell appears in the custom style rather than the default one. The following code example shows you how to apply cell style for a GridColumn.
{% highlight xml %}

<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrdersInfo}">
<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTextColumn MappingName="Freight" Format="C">
<syncfusion:GridTextColumn.CellStyle>
<Style TargetType="syncfusion:GridCell">
<Setter Property="Foreground" Value="Red" />
</Style>
</syncfusion:GridTextColumn.CellStyle>
</syncfusion:GridTextColumn>
</syncfusion:SfDataGrid.Columns>
</syncfusion:SfDataGrid> 



{% endhighlight %}

**SfDataGrid** also allows you to apply styles for the GridCells in a column based on conditions by writing a converter for the property in GridCell for which conditional styles need to be applied.
The following code example shows you how to apply conditional styling for a column by writing converter in **SfDataGrid**.
{% highlight xml %}

<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
xmlns:syncfusion="clr-namespace:Syncfusion.SfDataGrid.XForms;assembly=Syncfusion.SfDataGrid.XForms"
xmlns:local ="clr-namespace:DataGridSample;assembly=DataGridSample"
x:Class="DataGridSample.Sample">

<ContentPage.Resources>
<ResourceDictionary>
<local:CellStyleConverter x:Key="cellStyleConverter" />
</ResourceDictionary>
</ContentPage.Resources>

<ContentPage.BindingContext>
<local:ViewModel x:Name="viewModel" />
</ContentPage.BindingContext>

<syncfusion:SfDataGrid x:Name="dataGrid"
ItemsSource="{Binding OrdersInfo}">
<syncfusion:SfDataGrid.Columns>
<syncfusion:GridTextColumn MappingName="Freight" Format="C">
<syncfusion:GridTextColumn.CellStyle>
<Style TargetType="syncfusion:GridCell">
<Setter Property="BackgroundColor" 
Value="{Binding Freight, 
Converter={StaticResource cellStyleConverter}}" />
<Setter Property="Foreground" Value="Red" />
</Style>
</syncfusion:GridTextColumn.CellStyle>
</syncfusion:GridTextColumn>
</syncfusion:SfDataGrid.Columns>
</syncfusion:SfDataGrid>
</ContentPage>  



{% endhighlight %}

{% highlight c# %}
public class CellStyleConverter : IValueConverter
{
public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
{
if (System.Convert.ToDouble(value) < 300)
return Color.Red;
return Color.Green;
}

public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
{
return null;
}
} 



{% endhighlight %}

## Load More

**SfDataGrid** lets you to enable the LoadMore option by setting the **SfDataGrid.AllowLoadMore** property to true and by setting the **SfDataGrid.LoadMoreCommand** property. When the LoadMore is enabled, the **SfDataGrid** provides an option of loading a subset of data to its data source in the runtime using the LoadMore view. 
On scrolling down, when the grid reaches the maximum offset an interactive load more view is displayed in view. On tapping the load more view it triggers a command to add more data to the data source of the grid in runtime.
### LoadMoreCommand

**SfDataGrid** lets you load records to its data source in runtime by triggering an ICommand binded to the **SfDataGrid.LoadMoreCommand** property. When you tap the load more view, if the CanExecute of the ICommand returns true, then this command is triggered to load the records in runtime. 
You need to set the **SfDataGrid.IsBusy** property to true before loading the items to notify the grid that more items are loaded to it and set the property to false after loading the items to the grid. When loading the items, you can also alter the time for the LoadMore animation from the sample by setting a delay based on your requirement.
The following code example illustrates how to enable and load items in the runtime.
{% highlight c# %}
//Enable load more in SfDataGrid
dataGrid.AllowLoadMore = true;
dataGrid.LoadMoreCommand = new Command(ExecuteLoadMoreCommand); 
private async void ExecuteLoadMoreCommand()
{
this.dataGrid.IsBusy = true;
await Task.Delay(new TimeSpan(0, 0, 5));
viewModel.LoadMoreItems ();
this.dataGrid.IsBusy = false;
} 
//ViewModel.cs
internal void LoadMoreItems()
{
for (int i = 0; i < 20; i++)
this.OrdersInfo.Add(order.GenerateOrder(OrdersInfo.Count + 1));
} 



{% endhighlight %}

### LoadMore Customizations

**SfDataGrid** also allows you to customize the LoadMore view, the text displayed on the LoadMore view and their positions to either top or bottom based on the requirements.
#### Customize Load More Display Text

You can customize the text displayed in the load more view by setting the **SfDataGrid.LoadMoreText** property as below.
{% highlight c# %}
//setting load more text in SfDataGrid
dataGrid.LoadMoreText = "Load More Items"; 



{% endhighlight %}

#### Customize LoadMoreView Position

You can also customize the position in which the load more view is displayed to either top of bottom based on your requirements. 
{% highlight c# %}
//Enable load more in SfDataGrid
dataGrid.LoadMorePosition = LoadMoreViewPosition.Bottom;  



{% endhighlight %}

#### Customize LoadMoreView

**SfDataGrid** also allows you to customize the load more view based on your requirements. To do this you need to write your custom LoadMoreView class inheriting from the LoadMoreView and perform the LoadMoreOperation based on your requirement.
The following code example illustrates how to customize the LoadMoreView in **SfDataGrid**. 
{% highlight c# %}
public class CustomLoadMoreView : LoadMoreView
{
private Button loadMoreView;

public CustomLoadMoreView()
{
this.BackgroundColor = Color.Red;
loadMoreView = new Button ();
loadMoreView.Text = "LoadItems";
this.Children.Add(loadMoreView);
loadMoreView.Clicked += loadMoreView_Tapped;
}

void loadMoreView_Tapped (object sender, EventArgs e)
{
if (this.LoadMoreCommand != null)
{
this.LoadMoreCommand.Execute(null);
}
}

protected override void LayoutChildren(double x, double y, double width, double height)
{
loadMoreView.Layout(new Rectangle(x, y, width, height));
}
}   



{% endhighlight %}

## Pull To Refresh

This section explains you about how to enable and perform pull to refresh operation in **SfDataGrid**.

**SfDataGrid** lets you to enable the PullToRefresh option by setting the **SfDataGrid.AllowPullToRefresh** property to true and by setting the **SfDataGrid.PullToRefreshCommand** property. When the PullToRefresh is enabled, the **SfDataGrid** provides support for refreshing the data source in the runtime while doing the pull to refresh action. 

#### PullToRefreshCommand

**SfDataGrid** lets you refresh the data in view in runtime by triggering an ICommand binded to the **SfDataGrid.PullToRefreshCommand** property. While you perform pull to refresh action, if the progress bar meets 100 %, then this command is triggered to refresh the records in view. 
You need to set the **SfDataGrid.IsBusy** property to true before refreshing the records to notify the grid that pull to refresh action is being performed and set the property to false after the view is refreshed. You can also alter the time for the PullToRefresh animation from the sample by setting a delay based on your requirement.

The following code example illustrates how to enable and perform PullToRefresh operation in **SfDataGrid**.

{% highlight c# %}
//Enable PullToRefresh in SfDataGrid
dataGrid.AllowPullToRefresh = true;
dataGrid.PullToRefreshCommand = new Command(ExecutePullToRefreshCommand); 
private async void ExecutePullToRefreshCommand()
{
this.dataGrid.IsBusy = true;
await Task.Delay(new TimeSpan(0, 0, 5));
viewModel.ItemsSourceRefresh ();
this.dataGrid.IsBusy = false;
} 
//ViewModel.cs
internal void ItemsSourceRefresh()
{
int count = random.Next (1, 6);

for (int i = 11000; i < 11000 + count; i++) {
int value = i + random.Next (100, 150);
this.OrdersInfo.Insert (0, order.RefreshItemsSource (value));
}
} 



{% endhighlight %}

## Exporting

This section explains you how to Export the **SfDataGrid** to Excel and PDF file and about the customizations that can be done while exporting. 

**SfDataGrid** provides support for exporting the data to Excel and Pdf with several customization options like custom appearance, excluding specific columns, excluding headers, setting custom row height, setting custom column width, etc. It also provides support for Grouping, Filtering and Sorting when Exporting.

In order to use export to excel and export to pdf functionalities of **SfDataGrid**, add the required assembly references to your application as discussed in the [](#_Assembly_deployment "") HYPERLINK \l "_Assembly_deployment" section.

### Export to Excel

You can Export data to Excel by using the ExportToExcel method by passing the **SfDataGrid** as an argument. The following code example illustrates exporting data to Excel using the ExportToExcel Method.

{% highlight c# %}
private void ExportToExcel()
{
DataGridExcelExportingController excelExport = new DataGridExcelExportingController ();
var excelEngine = excelExport.ExportToExcel (this.dataGrid);
var workbook = excelEngine.Excel.Workbooks [0];
MemoryStream stream = new MemoryStream ();
workbook.SaveAs (stream);
workbook.Close ();
excelEngine.Dispose ();

if (Device.OS == TargetPlatform.WinPhone || Device.OS == TargetPlatform.Windows)
DependencyService.Get<ISaveWindowsPhone> ().Save ("DataGrid.xlsx", "application/msexcel", stream);
else
DependencyService.Get<ISave> ().Save ("DataGrid.xlsx", "application/msexcel", stream);
} 



{% endhighlight %}

#### Exporting Options

You can also Export data to Excel and Pdf with various customizing options while exporting the **SfDataGrid** by passing the grid and [](http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic55.html# "") HYPERLINK "http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic55.html" as arguments to the ExportToExcel method. The following code example illustrates this.
{% highlight c# %}
DataGridExcelExportingController excelExport = new DataGridExcelExportingController ();
DataGridExcelExportingOption exportOption = new DataGridExcelExportingOption ();
exportOption.ExportColumnWidth = false;
exportOption.DefaultColumnWidth = 150;
var excelEngine = excelExport.ExportToExcel (this.dataGrid, exportOption); 



{% endhighlight %}

**SfDataGrid** provides you with several [](http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic58.html# "") HYPERLINK "http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic58.html" class to customize the grid while exporting it to Excel. 

#### Events

The **SfDataGrid** provides you the following Events for Exporting to Excel:
* RowExporting – This Event is raised while exporting a row at the execution time before the row is exported.

* CellExporting – This Event is raised while exporting a cell at the execution time before the cell is exported.

##### RowExporting


The DataGridRowExcelExportingEventHandler delegate allows you to customize the styles for record rows and group caption rows. The RowExporting event is triggered with DataGridRowExcelExportingEventArgs that contains the following properties:
* Range – Specifies the Excel range to be exported. It provides full access to the exporting cell in Excel.

* Record – Gets the collection of underlying data objects that are exported.

* RowType – Specifies the row type by using ExportRowType Enum. You can use this property to check the row type and apply different styles based on the row type.

* Worksheet – Sets the Worksheet properties such as sheet protection, gridlines, and so on. 


You can use this event to customize the properties of the GridRows that are exported to excel and pdf. The following code example illustrates how to change the background color of the record rows and caption summary rows while exporting.
{% highlight c# %}
//HandlingRowExportingEvent for exporting to excel
DataGridExcelExportingController excelExport = new DataGridExcelExportingController ();
excelExport.RowExporting += excelExport_RowExporting; 

void excelExport_RowExporting (object sender, DataGridRowExcelExportingEventArgs e)
{
if (e.RowType == ExportRowType.Record) {
if ((e.Record.Data as OrderInfo).IsClosed)
e.Range.CellStyle.FillBackground = Syncfusion.XlsIO.ExcelKnownColors.Yellow;
else
e.Range.CellStyle.FillBackground = Syncfusion.XlsIO.ExcelKnownColors.LightGreen;
}
if (e.RowType == ExportRowType.CaptionSummary) {
e.Range.CellStyle.FillBackground = Syncfusion.XlsIO.ExcelKnownColors.Grey_25_percent;
}
} 



{% endhighlight %}

##### CellExporting

The DataGridCellExcelExportingEventHandler delegate allows you to customize the styles for header cells, record cells and group caption cells. The CellExporting event is triggered with DataGridCellExcelExportingEventArgs that contains the following properties:
* CellType – Specifies the cell type by using ExportCellType Enum. You can use this property to check the cell type and apply different cell styles based on the cell type.

* CellValue – Contains the actual value that is exported to the Excel. You can use this value to apply formatting in Excel using Range property.

* ColumnName – Specifies the Column Name (MappingName) of the exporting cell. You can apply formatting for a particular column by checking the ColumnName.

* Handled – Determines whether the cell is exported to Excel or not.

* Range – Specifies the Excel range to be exported. It provides full access to the exporting cell in Excel.

* Record – Gets the collection of underlying data objects that are exported. 


You can use this event to customize the properties of the GridCells that are exported to excel and pdf. The following code example illustrates how to customize the background color, Foreground color and CellValue of the header cells, record cells and caption summary cells while exporting.
{% highlight c# %}
//HandlingCellExportingEvent for exporting to excel
DataGridExcelExportingController excelExport = new DataGridExcelExportingController ();
excelExport.CellExporting += excelExport_CellExporting;  

void excelExport_CellExporting(object sender, DataGridCellExcelExportingEventArgs e)
{
if (e.CellType == ExportCellType.HeaderCell) {
e.Range.CellStyle.FillBackground = Syncfusion.XlsIO.ExcelKnownColors.Blue;
e.Range.CellStyle.FillForeground = Syncfusion.XlsIO.ExcelKnownColors.White;
e.CellValue = "HeaderCell";
}
if (e.CellType == ExportCellType.RecordCell) {
e.Range.CellStyle.FillBackground = Syncfusion.XlsIO.ExcelKnownColors.Yellow;
e.Range.CellStyle.FillForeground = Syncfusion.XlsIO.ExcelKnownColors.Black;
if (e.CellValue is string)
e.CellValue = "RecordCell";
}
if (e.CellType == ExportCellType.GroupCaptionCell) {
e.Range.CellStyle.FillBackground = Syncfusion.XlsIO.ExcelKnownColors.Grey_25_percent;
e.Range.CellStyle.FillForeground = Syncfusion.XlsIO.ExcelKnownColors.Blue;
e.CellValue = "CaptionSummary";
}
} 



{% endhighlight %}

### Export to Pdf

You can Export data to pdf by using the ExportToPdf method by passing the **SfDataGrid** as an argument. The following code example illustrates exporting data to Excel using the ExportToExcel Method.
{% highlight c# %}
private void ExportToPdf()
{
DataGridPdfExportingController pdfExport = new DataGridPdfExportingController ();
MemoryStream stream = new MemoryStream ();
var doc = pdfExport.ExportToPdf (this.dataGrid);
doc.Save (stream);
doc.Close (true);

if (Device.OS == TargetPlatform.WinPhone || Device.OS == TargetPlatform.Windows)
DependencyService.Get<ISaveWindowsPhone> ().Save ("DataGrid.pdf", "application/pdf", stream);
else
DependencyService.Get<ISave> ().Save ("DataGrid.pdf", "application/pdf", stream);
}



{% endhighlight %}

#### Exporting Options

You can also Export data to Pdf with various customizing options while exporting the **SfDataGrid** by passing the grid and [](http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic100.html# "") HYPERLINK "http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic100.html" as arguments to the ExportToPdf method. The following code example illustrates this.
{% highlight c# %}
DataGridExcelExportingController excelExport = new DataGridExcelExportingController ();
DataGridExcelExportingOption exportOption = new DataGridExcelExportingOption ();
exportOption.ExportColumnWidth = false;
exportOption.DefaultColumnWidth = 150;
var excelEngine = excelExport.ExportToExcel (this.dataGrid, exportOption); 
DataGridPdfExportingController pdfExport = new DataGridPdfExportingController ();
DataGridPdfExportOption exportOption = new DataGridPdfExportOption ();
exportOption.FitAllColumnsInOnePage = true;
var doc = pdfExport.ExportToPdf (this.dataGrid, exportOption); 




{% endhighlight %}

**SfDataGrid** provides you with several [](http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic103.html# "") HYPERLINK "http://help.syncfusion.com/cr/cref_files/xamarin/sfgridconverter/topic103.html" class to customize the grid while exporting it to Pdf. 
#### Events

The **SfDataGrid** provides you the following Events for Exporting:
* RowExporting – This Event is raised while exporting a row at the execution time before the row is exported.

* CellExporting – This Event is raised while exporting a cell at the execution time before the cell is exported.

##### RowExporting


The DataGridRowExcelExportingEventHandler delegate allows you to customize the styles for record rows and group caption rows. The RowExporting event is triggered with DataGridRowExcelExportingEventArgs that contains the following properties:
* PdfGrid – You can use this property to customize the PdfGrid’s properties such as Background, CellPadding, CellSpacing etc.

* PfdRow – Specifies the PDFGridRow to be exported. You can use this to customize the properties of particular row. 

* Record – Gets the collection of underlying data objects that are exported.

* RowType – Specifies the row type by using ExportRowType Enum. You can use this property to check the row type and apply different styles based on the row type.


You can use this event to customize the properties of the GridRows that are exported to excel and pdf. The following code example illustrates how to change the background color of the record rows and caption summary rows while exporting.
{% highlight c# %}
//HandlingRowExportingEvent for exporting to pdf
DataGridPdfExportingController pdfExport = new DataGridPdfExportingController ();
pdfExport.RowExporting += pdfExport_RowExporting; 
void pdfExport_RowExporting (object sender, DataGridRowPdfExportingEventArgs e)
{
if (e.RowType == ExportRowType.Record) {
if ((e.Record.Data as OrderInfo).IsClosed)
e.PdfRow.Style.BackgroundBrush = PdfBrushes.Yellow;
else
e.PdfRow.Style.BackgroundBrush = PdfBrushes.LightGreen;
}
if (e.RowType == ExportRowType.CaptionSummary) {
e.PdfRow.Style.BackgroundBrush = PdfBrushes.LightGray;
}
} 



{% endhighlight %}

##### CellExporting

The DataGridCellExcelExportingEventHandler delegate allows you to customize the styles for header cells, record cells and group caption cells. The CellExporting event is triggered with DataGridCellExcelExportingEventArgs that contains the following properties:
* CellType – Specifies the cell type by using ExportCellType Enum. You can use this property to check the cell type and apply different cell styles based on the cell type.

* CellValue – Contains the actual value that is exported to the Excel. You can use this value to apply formatting in Pdf using Range property.

* ColumnName – Specifies the Column Name (MappingName) of the exporting cell. You can apply formatting for a particular column by checking the ColumnName.

* Handled – Determines whether the cell is exported to Pdf or not.

* PdfGrid – Specifies the PDFGridCell to be exported. You can use this to customize the properties (Background, Foreground, Font, Alignment etc.,) of particular cell.

* Record – Gets the collection of underlying data objects that are exported.


You can use this event to customize the properties of the GridCells that are exported to excel and pdf. The following code example illustrates how to customize the background color, Foreground color and CellValue of the header cells, record cells and caption summary cells while exporting.
{% highlight c# %}
//HandlingCellExportingEvent for exporting to pdf
DataGridPdfExportingController pdfExport = new DataGridPdfExportingController ();
pdfExport.CellExporting += pdfExport_CellExporting;  
void pdfExport_CellExporting(object sender, DataGridCellPdfExportingEventArgs e)
{
if (e.CellType == ExportCellType.HeaderCell) {
e.PdfGridCell.Style.BackgroundBrush = PdfBrushes.Blue;
e.PdfGridCell.Style.TextBrush = PdfBrushes.White;
e.CellValue = "HeaderCell";
}
if (e.CellType == ExportCellType.RecordCell) {
e.PdfGridCell.Style.BackgroundBrush = PdfBrushes.Yellow;
e.PdfGridCell.Style.TextBrush = PdfBrushes.Black;
if (e.CellValue is string)
e.CellValue = "RecordCell";
}
if (e.CellType == ExportCellType.GroupCaptionCell) {
e.PdfGridCell.Style.BackgroundBrush = PdfBrushes.LightGray;
e.PdfGridCell.Style.TextBrush = PdfBrushes.Blue;
e.CellValue = "CaptionSummary";
}
}  



{% endhighlight %}

## ColumnSizer

**SfDataGrid** allows you to apply ColumnSizer for the GridColumns by setting the **SfDataGrid.ColumnSizer** property. 

The following code example illustrates how to apply ColumnSizer in **SfDataGrid**.

{% highlight c# %}

dataGrid.ColumnSizer = ColumnSizer.None;  

{% endhighlight %}

**SfDataGrid** applies width for all the GridColumns in the **SfDataGrid.Columns** collection based on the **SfDataGrid.ColumnSizer** property. Following are the lists of options available to set width of the Columns.

* None

* LastColumnFill

* Star

### ColumnSizer.None

No Column sizing is applied when the **SfDataGrid.ColumnSizer** is set to “None”. Columns are arranged in view based on the **SfDataGrid.DefaultColumnWidth** property. This is the default value of the **SfDataGrid.ColumnSizer** property.

### ColumnSizer.LastColumnFill

When the **SfDataGrid.ColumnSizer** is “LastColumnFill”, the column width of the GridColumns are adjusted with respect to **SfDataGrid.DefaultColumnWidth** property. In case if the columns does not fill the entire view space, then the last column’s width fills the unoccupied space in the view.

### ColumnSizer.Star

When the **SfDataGrid.ColumnSizer** is “Star”, all the GridColumns are adjusted an equal column width to fit within the view. Setting ColumnSizer to “Star” will disable the HorizontalScrolling in **SfDataGrid**.

N> If any column is specified a width explicitly using the GridColumn.Width property then that column is not considered ColumnSizing width and skipped while applying the ColumnSizer for grid columns.

## Freeze panes

This section explains you how to set Freeze panes in **SfDataGrid**. 

### Freeze Rows

**SfDataGrid** provides extensive support to freeze the rows at the top of the view below the header row by setting the **SfDataGrid.FrozenRowsCount** property. 

The following code example illustrates freezing two rows in **SfDataGrid**.

{% highlight c# %}

//Setting number of rows to freeze in SfDataGrid
dataGrid.FrozenRowsCount = 2; 

{% endhighlight %}

#### Limitation

* FrozenRowsCount should be lesser than the number of rows that is displayed in View.

* For example: 
If you have 10 rows in view, then you set FrozenRowsCount to a maximum value of 9.


N> Header row is frozen by default and works regardless of the FrozenRowsCount property.

### Freeze Columns

**SfDataGrid** also provides support to freeze the columns at the left of the view by setting the **SfDataGrid.FrozenColumnsCount** property. 

The following code example illustrates freezing two columns in **SfDataGrid**.

{% highlight c# %}

//Setting number of columns to freeze in SfDataGrid
dataGrid.FrozenColumnsCount = 2;  



{% endhighlight %}

#### Limitation

* FrozenColumnsCount should be lesser than number of columns displayed in View.

* For example: 
If you have 5 columns in view, then you can set FrozenColumnsCount to a maximum value of 4.


N> RowHeader is frozen by default and works regardless of the FrozenColumnsCount property.

## Row Height Customization

This section explains you about how to customize the height of the rows in **SfDataGrid**.

**SfDataGrid** provides you the options to customize the header row height and the row height of all the grid rows or particular rows based on your requirements. The following sections illustrates you about how to achieve this customization in **SfDataGrid**.

### Customize HeaderRowHeight 

**SfDataGrid** allows you to customize the height of the header row by setting the **SfDataGrid.HeaderRowHeight** property. The default value of this property is 40. This property responds to runtime changes and hence you can customize it based on your requirement. Setting **SfDataGrid.HeaderRowHeight** to zero will collapse the header row in view.

The following code example illustrates how to customize header row height in **SfDataGrid**.

{% highlight c# %}

//Customizing header row height in SfDataGrid
dataGrid.HeaderRowHeight = 50;  



{% endhighlight %}

### Customize RowHeight for all rows

**SfDataGrid** allows you to customize the height of the grid rows in the scrolling region by setting the **SfDataGrid.RowHeight** property. The default value of this property is 50. This property responds to runtime changes and hence you can customize it based on your requirement. Setting this property will change the height of all the rows in the body region with the common value. Setting **SfDataGrid.RowHeight** to zero will collapse all the rows in the grid.

The following code example illustrates how to customize header row height in **SfDataGrid**.

{% highlight c# %}

//Customizing row height in SfDataGrid
dataGrid.RowHeight = 60;  

{% endhighlight %}

### Customize RowHeight of a particular row on demand

**SfDataGrid** allows you to customize the height of a grid row on demand by handling the **SfDataGrid.QueryRowHeight** event. This event is raised for the grid rows whenever they come to view and hence you can customize the height of a particular row on demand by using the row index. Setting height to zero will collapse all the row in the grid. 

#### QueryRowHeight

QueryRowHeight is the event that returns row heights on demand. This event receives two arguments namely the sender that handles the **SfDataGrid** and the QueryRowHeightEventArgs. The QueryRowHeightEventArgs has the following properties.

* RowIndex: The property RowIndex helps you to identify a particular row in the grid.

* Height: This property sets and returns the height for a grid row on demand. Default line size for the rows is 50.

* Handled: This property decides whether the specified height can be set to row or not. The default value is false. When this property is not set, the decided height is not set to the row.

The following code example illustrates how to hook the QueryRowHeight event and customize a row‘s height in **SfDataGrid**.

{% highlight c# %}

//Hooks QueryRowHeight event in SfDataGrid
dataGrid.QueryRowHeight += DataGrid_QueryRowHeight;  
//Event to set the row height on demand
void DataGrid_QueryRowHeight (object sender, QueryRowHeightEventArgs e)
{
//Sets height of the fifth row
if (e.RowIndex == 5) {
e.Height = 100;
e.Handled = true;
}
} 

{% endhighlight %}

{% endtabs %}